# RobKing_MIT6.824
# MIT 6.824 分布式系统 | Lab 1：MapReduce

## 项目总览

首先明确我们需要做的事情：就是统计电子书所有单词出现的次数。其次这整个框架我们需要用到的就是两个包，一个是`main`包，一个是`mr`包，其中`main`包下的`mrmaster.go`和`mrworker.go`是用来调用`mr`包下的`master.go`和`worker.go`。

这个框架给了我们一个非分布式的实现方法在`main/mrsequential.go`，而我们需要做的就是实现一个分布式系统用来统计。`master`相当于老板，`worker`相当于工人，每个工人会向老板索要任务，老板给他们分配任务，他们之间通过`RPC`进行通信，分配的任务有两种，一种是`Map`任务，即将电子书的所有单词分离出来，通过键值对保存，可能会有很多重复的，所以还有一种任务就是`Reduce`任务，即将重复的键值对进行合并，这样我们就可以得到所有单词出现的次数。

## 必备的背景知识

### `RPC`通信

简单介绍一下`RPC`通信，主要是服务端和客户端，服务端注册服务，客户端调用这个服务就相当于本地调用函数一样。

服务端注册的流程如下：

1. 通过`rpc.Register()`方法注册`RPC`服务，参数为结构体
2. 通过`rpc.HandleHTTP()`将`RPC`服务绑定到`HTTP`，没有参数
3. 通过`http.ListenAndServer()`监听一个端口，第一个参数是`ip+port`，第二个参数是`nil`
4. 实现RPC服务的功能，功能函数必须按照规范来，`func(结构体) 功能(Args, *Result){}`

客服端调用的流程如下：

1. 通过`rpc.DailHTTP()`建立连接，第一个参数是`TCP`协议，第一个参数是`ip+port`
2. 直接通过`Call()`方法调用服务器实现好的功能，第一个参数是功能(string)，第二个为传入的参数结构体，第三个为返回的结果结构体

### `go --plugin`(动态库)

了解`go`语言的`plugin`有利于更好地理解这之间的调用关系。首先会有一个`go`文件实现了一个方法，接下来我们使用如下指令生成`.so`文件

```golang
go build -race -buildmode=plugin *.go
```

接下来主函数(执行 `go run main.go *.so）`可以通过`*.so`文件调用其中的函数或者仅仅获取函数。这其中有两个重要的`API`

- 一个是 `pdll, err := plugin.Open("*.so")`用来打开动态库
- 另一个是 `funcName, err := pdll.LookUp("funcName")`用来获取方法，返回的是`interface{}`类型
- 通过这个方法我们可以得到 `funcName.(函数参数类型)（函数参数）`来调用函数

## 非分布式的实现方法思路

这个是官方提供的在`main/mrsequential.go`，具体是这样实现的。

首先是读取电子书的内容，接着调用`Map`函数执行`Map`任务，`Map`函数是通过将读取到的文件内容转化为单词数组的形式，然后遍历这个数组，将每个单词的`value`记为1，返回键值对。这样我们就获得了键值对，紧接着我们对这些键值对进行排序，使相同的放在一块，遍历这些键值对，将相同的单词执行`Reduce`任务，`Reduce`函数就是传入字符串数组，返回他的长度，这个长度就是我们要的每个单词出现的次数，这个数组主要是将相同的单词的`value`加入到里面，其实就是很多个`“1”`，同时将执行完`Reduce`任务的键值对输入到`mr-out-0`文件即可。

实现起来也是相当的简单，我们可以参考里面读写文件的操作来实现我们的分布式系统。接下来就是分布式的具体实现。
